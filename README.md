# c.a_data
1. 출력
(1) System.out.println(“”);
“”안에 문자를 입력하거나 변수를 입력하여 출력할 수 있다.
문자와 변수를 같이 출력할때 (“”+a)식으로 덧셈 연산자로 합칠 수 있다.
“”안에 \n을 넣어 줄바꿈을 할 수 있다.

(2) System.out.print(“”);
println()과 기능은 비슷하나 println()는 실행 후 줄바꿈을 하지만 
print()는 실행 후 줄바꿈을 하지 않는다.

(3) System.out.printf();
ex) System.out.printf(“출력%d”,a);
형식화된 출력이고 앞에 출력하려고 하는 문자와 변수를 입력하고 뒤에 변수들을 입력한다.
println은 출력하면 줄바꿈을 하지만 printf는 줄바꿈을 하지 않는다.
지시자:
%d 10진수 (정수)
%f 10진수 (실수)
%s 문자 (string)
%c 문자 (char)
%n 줄바꿈

2. 입력
먼저 입력 받기 위해 scanner를 import해준다.
import java.util.Scanner;
그리고 실행할 코드를 입력하는 곳에 scanner를 사용할 함수를 선언해 준다.
Scanner scanner = new Scanner(System.in);
scanner로 입력을 받아 문자로 저장하는 변수를 선언한다.
String input = scanner.nextLine();
문자를 받는 변수를 선언한 후에 입력을 잗아 저장하는 것도 상관없다.
ex)
String input;
input = scanner.nextLine();
출력할때는 println을 쓰거나 printf를 쓰면 된다.
System.out.println(input);
System.out.printf(“%s”,input);

3. 변수
ex) int a;
이런 식으로 정수형인 변수 a를 선언한다

ex) int a = 10;
이런식으로 변수를 선언함과 동시에 값을 초기화시켜준다

그리고 처음 변수를 선언하고 최종일 경우 앞에 final을 붙여 준다.
ex) final int a = 0;

만약 변수 타입을 바꾸고 싶으면 변수를 초기화할때는 변수 앞에 변환하고자하는 타입을 괄호와 함께 붙여주면 된다.
(타입)피연산자

ex)
double input = 3.14; //변수 타입이 실수형으로 초기화됨
int intValue = (int)input //실수형 input변수를 정수형으로 바꿔 정수인 3만 초기화됨
System.out.println(input);

변수 기본형 종류
논리형: boolean (true나 false 중 하나의 값을 가지며, 조건식과 논리적 계산에 사용한다)
문자형: char, string
정수형: int
실수형: float, double
(char은 한 문자만 저장할수 있으면 저장할때 문자 양쪽에 '를 붙여줘야 한다. string은 문자나 문자열을 저장할수 있으며 저장할때 양쪽에 "를 붙여줘야 한다)

4. 연산자
연산자: 연산을 수행하는 기호(+,-,*,/ 등)
피연산자: 연산자의 작업 대상(변수, 상수, 수식)
ex) x + 3
연산자: +, 피연산자: x, 3
(1) 사칙 연산자 + - * /
사칙 연산자는 아마도 프로그래밍에서 가장 많이 사용되는 연산자들 일 것이다. 피연산자가 정수인 경우, 나누는 수로 0을 사용할 수 없다.
(2) 비교 연산자
a<b
a>b
a<=b
a>=b
(3) 등가비교 연산자
a==b 두 값이 같으면 true 아니면 false
a!=b 두 값이 다르면 true 아니면 false

5. if문
if는 "만약"이라는 뜻으로 조건뭉에 쓰인다.
만약 ~라면, ~를 실행한다
ex)
int c = 0;
if (c == 0) {
  system.out.println(c);
}
이처럼 if문 바로 뒤에 조건문을 중괄호 뒤에 써준다.
그리고 그 조건이 참이라면 중괄호 안에 있는 실행문을 작동시킨다.
[참고] 등호를 한번만 쓰면 왼쪽 변수에 오른쪽 값을 지정하는 것이고 등호를 두개쓰면 왼쪽과 오른쪽이 같다가 된다.
만일 조건이 거짓이라면 중괄호 안에 있는 실행문은 동작하지 않고 if문을 빠져나간다.
거짓일때 다르게 샐행 시키려면 else를 쓰면 된다.
ex)
int c = 0;
if (c == 0) {
  system.out.println(c);
}
else {
  system.out.println("false");
}
그리고 2개 이상의 조건식이 있다면 else if를 써서 "만약 ~면 ~를 실행하고 그 조건이 아니라 ~라면 ~를 실행한다" 를 표현할수 있다.
ex)
int c = 0;
if (c == 0) {
  system.out.println(c);
}
else if (c == 1) {
  systme.out.println("2")
  }
else {
  system.out.println("3");
}
코드에서 else if문으로 c가 0이 아니라 1이면 2를 출력한다을 표현한 것이다.
  
6. switch문
if문은 조건식의 결과가 참과 거짓, 두 가지 밖에 없기 때문에 경우의 수가 많아질수록 else if를 계속 추가해야 하므로 조건식이 많아져서 복잡해지고,
여러 개의 조건식을 계산해야하므로 처리시간도 많이 걸린다.
이러한 if문과는 달리 switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고, 표현도 간결하므로 알아보기 쉽다.
그래서 처리할 경우의 수가 많은 경우애는 if문 보다 switch문을 작성하는 것이 좋다.
먼저 switch문의 기본구조는 아래와 같다.
switch (조건식) {
  case 값1:
    //조건식의 결과가 값1과 같을 경우 수행될 문장들
    break;
  case 값2:
    //조건식의 결과가 값2과 같을 경우 수행될 문장들
    break;
  default:
    //저건식의 결과와 일치하는 case문이 없을때 수행될 문장들
}
switch문은 조건식을 먼저 계산한 다음, 그 결과와 일치하는 case문으로 이동한다. 
아동한 case문 아래에 있는문장을 수행하며, break문을 만나면 전체 switch문을 빠져나가게 된다.
이러한 switch문은 항상 if문으로 변환이 가능하지만, if문은 switch문의 제약조건때문에 sxitch문으로 작성할 수 없는 경우가 많다.
switch문의 제약조건은 다음과 같다.
  (1) switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
  (2) case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.

7. while문
while문은 반복문으로 조건식이 참이면 실행문을 실행하는것을 반복한다
while문의 구조는 아래와 같다
while (조건식) {
  //조건문이 참이면 수행될 문장들
}
위에 while문의 실행 순서는 다음과 같다
(1) 조건식이 참이면 {}안으로 들어가고, 거짓이면 while문을 벗어난다.
(2) {}의 문장을 수행하고 다시 조건식으로 들어간다.
ex)
int i=1;
while (i<=10) {
  //실행문
  i++
}
위에 예시는 실행문을 10번 반복한다.
  
8. for문
for문은 반복 횟수를 알고 있을 때 적합하다. 구조가 조금 복잡하지만 직관적이라 이해하기 쉽다
ex)
for (int i=1;i<=;i++;) {
  System.out.println(“I can do it.”);
}
위에 예시는 I can do it을 5번 출력한 것이다.
for문의 구조는 다음과 같다
for(초기화;조건식;증감식;) {
  //실행문
}
조건문이 참인 동안 {}내의 문장들을 반복하다 거짓이 되면 반복문을 벗어난다.
제일 먼저 초기화가 수행되고, 그 이후부터는 조건식이 참인 동안 조건식->수행될 문장->증감식 순서로 계속 반복된다. 그러다가 조건문이 거짓이 되면 for문 전체를 빠져나가게 된다.
초기화
반복문에 사용될 변수를 초기화하는 부분이며 처음에 한번만 수행된다.보통 변수 하나로 for문을 제어하지만, 둘 이상의 변수가 필요할 때는 콤마’,’를 구분자로 변수를 초기화하면 된다. 단, 두 변수의 타입은 같아야한다
조건식
조건식이 값이 참이면 반복을 계속하고 거짓이면 반복을 중단하고 for문을 벗어난다. for의 뜻이 ‘~하는 동안’이므로 조건식이 ‘참인 동안’ 반복을 계속한다고 생각
  
9. break문
break문은 현재 위치에서 가장 가까운 sxitch문이나 반복문을 빠져나온다

ex)
int sum = 0;
int i = 1;

while(true){
  if(sum > 100){
    break;
  }
  sum += 1;
  i++
}
위 코드는 sum이 100보다 커지면 break문이 실행되어 즉시 반복문을 빠져나온다
ex)
for(int i = 0;i <= 10;i++) {
  if
}
  
11. continue문
continue문은 반복문 내만 사용될 수 있으며, 반복이 진행 중에 continue문을 만나게 되면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.
ex)
for(imt i=0; i<= 10; i++) {
  if(i%3 == 0) {
  continue;
  }
  System.out.println(i);
}

13. 배열
배열이란 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것이다.
예를 들어 학생 5명의 점수를 저장하기 위해서 5개의 변수를 선어해야 할 것이다.
int score1, score2, score3, score4, score4, score5;
변수 대신 배열을 사용하면 다음과 같이 간단히 처리할 수 있다. 변수의 선언과 달리 다뤄야할 데이터 수가 아무리 많아도 단지 배열의 길이만 바꾸면 된다.
int[] score = new int[5];
값을 저장할 수 있는 공간이 score[0]부터 score[4]까지 모두 5개이며, 변스 score는 배열을 다루는데 필요한 참조변수일 뿐 값을 저장하기 위한 공간은 아니다.
변수와 달리 배열은 각 저장공간이 연속적으로 배치되어 있다는 특징이 있다.

(1) 배열 선언과 생성
  선언방법: 타입[] 변수이름:
  선언 예: int[] score:, String[] name:
  배열의 생성: 변수이름 = new 타입[길이];
  코드로 하면
  타입[] 변수이름;             //배열을 선언 (배열을 다루기 위한 참조변수 선언)
  변수이름 = new 타입[길이];   //배열을 생성 (실제 저장공간을 생성)

  아래의 코드는 '길이가 5인 int배열'을 생성한다.
  int[] score;
  score = new int[5];

  다음과 같이 배열의 선언과 생성을 동시에 하면 간략히 한 줄로  할 수 있다
  타입[] 변수이름 = new 타입[길이];
  int[] score = new int[5];

(2) 배열의 길이와 인덱스
  생성된 배열의 각 저장공간응 '배열의 요소'라고 하며, '배열이름[인덱스]'의 형식으로 배열의 요소에 접근한다. 
  인덱스는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용된다.
  인덱스(index)의 범위는 0부터 '배열길이-1'까지.
  예를 들어 길이가 5인 배열은 모두 5개의 요소(저장공간)를 가지며 
  인덱스의 범위는 1부터 5까지가 아닌 0부터 4까지, 즉 0, 1, 2, 3, 4가 된다.
  int[] score = new int[5]; //길이가 5인 int배열

  배열을 생성할때 괄호[]안에 배열의 실이를 적어줘야 하는데, 배열의 길이는 배열의 요소의 개수, 즉 값을 저장할 수 있는 공간의 개수다.
  배열의 길이는 당연히 양의 정수이어야 한다.
  타입[] 배열이름 = new 타입[길이];
  itn[] arr = new int[5]; //길이가 5인 int배열

  배열이름.length
  int[] arr = new int[5]; //길이가 5인 int배열
  int tmp = arr.length;   //arr.length의 값은 5이고 tmp에 5가 저장된다
  배열은 한번 생성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다. 
  따라서 '배열이름.length'는 상수이다. 즉, 읽을 수만 있을 뿐 변경할수는 없다. 

(3) 배열의 초기화
  배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 되지만, 원하는 값을 저장하려면 아래와 같이 각 요소마다 값을 지정해 줘야 한다.
  int[] score = new int[5] //길이가 5인 int배열 생성
  score[0] = 50;           //각 요소에 직접 값을 저장
  score[1] = 60;
  score[2] = 70;
  score[3] = 80;
  score[4] = 90;
  배열의 길이가 큰 경우에는 이렇게 요소 하나하나에 값을 지정하기 버다는 for문을 사용 하는 것이 좋다. 위의 코드를 for문을 이용해서 바꾸면 다음과 같다.
  int[] score = new int[5] //길이가 5인 int배열 생성

  for (int i=0; i < score.length; i++) {
    score[i] = i * 10 + 50;
  }
  그러나 for문으로 배열을 초기화 하려면, 저장하려는 값에 일정한 규칙이 있어야만 가능하기 때문에 자바에서는 다음과 같이 배열을 간단히 초기화 할 수 있는 방법을 제공한다.
  int[] score = new score[]{50, 60, 70, 80, 90}; //배열의 생성과 초기화를 동시에
  괄호{}안에 저장될 값들을 쉼표로 구분해서 나열하면 되며 괄호[]안에 배열의 길이는 결정되지 않는다.
  괄호{}안에 적힌 갑스이 개수에 의해 배열의 길이가 자동적으로 결정되기 때문이다.
  int[] score = { 50, 80 70, 80, 90};
  위와 같이 'new 타입[]'을 생략하여 코드를 더 간단히  할 수도 있다.

(4) 배열의 출력
  배열을 초기화 할때 for문을 사용하듯이, 배열을 저장에 저장된 값을 확인할 때도 다음과 같이 for문을 사용하면 된다.
  int[] iArr = {100, 95, 80, 70, 60

  for(int i = 0 ; i < iArr.length; i++){
            System.out.println(iArr[i]);
  }
  println매서드는 출력 후에 줄 바꿈을 하므로, 여러 줄에 걸쳐 출력되어 보기 불편할 때가 있다. 그럴때는 다음과 같이 출력 후에 줄 바꿈하지 않는 print매서드를 사용하는 것이 좋다.
  int[] iArr = {100, 95, 80, 70, 60};

  for(int i = 0 ; i < iArr.length; i++){
            System.out.print(iArr[i]);
  }
  System.out.println(); //다음 출력이 바로 이어지지 않도록 줄 바꿈을 한다.

  더 간단한 방법은 'Arrays.toString(배열이름)'메서드를 사용하는 것이다. 이 메서드는 배열의 모든 요소를'[첫번째 요소,두번째요소, ...]'와 같은 형식의 문자열로 만들어서 반환한다.
  int[] iArr = {100, 95, 80, 70, 60};
  
  System.out.println(Arrays.toString(iArr)); // [100, 95, 80, 70, 60]
  char배열은 println메서드로 출력하면 각 요소가 구분자없이 그대로 출력되는데 이것은 println메서드가 char배열일 때만 이렇게 동작하도록 작성되었기 때문이다.
  char[] chArr = { 'a', 'b', 'c', 'd' };
  System.out.println(chArr); //abcd가 출력됨.

(5) 배열의 복사
  배열의 복사는 두가지 방법이 있다.
  첫 번째는 for문을 활용해서 한 배열의 모든 요소에 저장된 값을 하나씩 다른 배열에 저장하는 방식이 있다,
  두 번째는 System.arraycopy()를 이용한 배열의 복사가 있다.
  for문은 배열의 요소 하나하나에 접근해서 복사하지만, System.arraycopy()는 지정된 값들을 한 번에 통째로 복사한다.
  각 요소들이 연속적으로 저장되어 있다는 배열의 특성때문에 이렇게 처리하는 것이 가능한 것이다.
  배열의 복사는 for문보다 System.arraycopy()를 사용하는 것이 효율적이다
  배열의 복사에 사용된 for문을 System.arraycopy()로 바꾸면 다음과 같다.
  for(int i=0; i < num.length; i++); {  newNum[i] = num[i]; }
  ->
  System.arraycopy(num, 0, newNum, 0, num.length);
  arraycopy()를 호출할 때는 어느 배열의 몇 번째 요소에서 어느 배열로 몇 번째 요소로 몇 개의 값은 복사할 것인지 지정해줘야 하는데, 다음과 같이 생각하면 이해하기 쉽다.
  System.arraycopy(num, 0, newNum, 0, num.length);
  ->
  num[0]에서 newNum[0]으로 num.length개의 데이터를 복사
  ex) 
  char[] abc = { 'A', 'B', 'C', 'D'};
  char[] num = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

  char[] result = new char[abc.length+ num.length];
  System.arraycopy(abc, 0, result, 0, abc.length);
  System.arraycopy(num, 0, result,abc.length, num.length);
  System.out.println(result); //ABCD0123456789
